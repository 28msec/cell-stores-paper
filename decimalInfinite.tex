\documentclass{acm_proc_article-sp}
\usepackage{graphicx}
\usepackage{balance} 
\usepackage{multirow}
\usepackage{listings}
\usepackage{url}
\usepackage[usenames,dvipsnames]{color}
\begin{document}

\title{decimalInfinite: A Lossless, Order-Preserving Binary Encoding Of All Decimals}

\numberofauthors{1}

\author{
\alignauthor
Ghislain Fourny\\
       \affaddr{28msec, Inc.}\\
       \affaddr{Z\"urich, Switzerland}\\
       \email{g@28.io}
}
\date{6 March 2015}
\maketitle

\begin{abstract}
Yes, all of them.
\end{abstract}

\section{introduction}
In the early stages of computers, storage was scarce. And it was even scarcer in the processor itself. The first computers supported basic arithmetic operations on 8-bit integers. As more memory was needed, the size of the registers in the processor architecture was increased to successively 16 bits, 32 bits and very recently to 64 bits.

While this was mostly driven by the size of the memory, which never failed to exceed the maximum value space at some point, this is also had an impact on the size of integers and decimals processed. This is simply because, in the Von-Neumann architecture, registers are both used to store memory addresses and numbers.

The numbers used in programs are of two main kinds: integers and decimals. Integers are typically supported within a complete interval such as $- 2^{31}$ to $2^{31} -1$. In the case of decimals, it is a bit more complicated. They are limited both in range (driven by the size of their exponent) and in their precision.

For scientists that need to use bigger numbers and/or more precision, special libraries are available, and domain-specific software such as Maple, Mathematica or Matlab make it possible to overcome the limitations of processors and shield the user from the complex machinery that is required to have the processor perform the computations.

In the modern database era, notably document stores, syntaxes such as XML and JSON, but also their data models and the associated query languages, do not impose any limitation on integers or decimals: on the logical level, the entire value space is covered and the limit is only the size of the available storage.

The difference with scientific software, though, is that there is more to it than performing computations. These numbers need to be efficiently stored and retrieved, but most importantly, this must be done in such a way that they can be indexed. For efficiency reasons, it is desirable that this comparison can be done without decoding them. While this is trivial for hash indices, it becomes more difficult for range indices. Indeed, the lexicographical order of encoded values must correspond to the ordering of the corresponding numbers.

State-of-the-art databases, still, do not support yet such an encoding that would cover the entire decimal space (that is, the entire value space of the XML xs:decimal type, or the entire value space of JSON numbers).

This paper contributes an encoding that solves this problem. The encoding and decoding algorithms have been implemented in C++ and are used on production machines to store decimals as BSON binaries, on a MongoDB data store.

\subsection{Outline of the encoding}

The encoding relies on decomposing the underlying decimal into a normal form, as is typically done in other encodings. This decomposition is made of an overall sign, an exponent sign, an exponent and a significand. These four components are encoded in turn and in this order.

Section \ref{section-related-work} gives an overview of the integer and decimal encoding landscape.
TODO
Finally, we give a few hints on how the encoding can be fine-tuned to specific needs, such as also supporting special values such as negative 0, NaN, and infinity.

\section{Related work}
\label{section-related-work}

\subsection{Natural encoding}

\subsection{Signed Integers}

\subsection{IEEE float and double encoding}

\subsection{Elias Gamma Code}

 Gamma codes are used to encode infinite-range exponents.
 
This encoding unifies previous works and solves the general problem of order preserving for the entire decimal range.

The Elias gamma code solves the infinite-range order-preserving issue for integers only. US Patent 7685214 solves the order-preserving issue for finite-range decimals only.

None of the Elias gamma code or the US Patent 7685214 supports infinite-range decimals.

This invention unifies the Elias gamma code approach to encode exponents, and the US Patent 7685214 approach to encode the sign, exponent and mantissa separately, the mantissa being encoded in declets.

\subsection{IBM Patent}


\section{Summary}

The invention provides an algorithm (6) for encoding a decimal into a variable-length representation. This algorithm works by writing the decimal in a normal form (1), splitting the normal form into 4 components (2), encoding each of these components separately: sign (3), exponent and its sign (4), significand (5), and finally concatenating the encodings. The lexicographical ordering of the binary encodings corresponds to the natural ordering of the underlying decimals (9). A decoding algorithm (7) retrieves the encoded decimal from its encoding. Finally, special values such as -0, -INF and +INF are encoded separately (8), in a way that preserves their order relationship with other decimals. Nan is encoded separately as the lowest.

Relationship Between the Components (continued)

\section{Encoding}

\subsection{Encoding the sign}

00 corresponds to a - sign
10 corresponds to a + sign

\subsection{Encoding the exponent}
\begin{enumerate}
\item The exponent is offset by +2.
\item  The exponent is written in a binary form.
\item  Call N the number of its digits.
\item  The first digit is replaced with N-1 ones, followed by a zero.
\item  If the overall sign and the sign of its exponent are different, all digits are inverted (NOT).
\end{enumerate}

\subsection{Encoding the significand}
\begin{enumerate}
\item If the sign of the decimal is negative, 10-S is encoded instead.
\item Decomposition into one leading digit, followed by groups of 3 digits (declets) after the comma.
\item Padding of the last declet with 0s to make sure it also has 3 digits.
\item Encoding of the leading digit in 4 bits (natural binary representation).
\item Encoding of each declet in 10 bits (natural binary representation).
\end{enumerate}

\section{Decoding}

\subsection{Decoding the exponent}

\subsubsection{The exponent sign}

\begin{enumerate}
\item If the overall sign is - and the encoding begins with a 0, the exponent sign is +.
\item If the overall sign is - and the encoding begins with a 1, the exponent sign is -.
\item If the overall sign is + and the encoding begins with a 0, the exponent sign is -.
\item If the overall sign is + and the encoding begins with a 1, the exponent sign is +.
\end{enumerate}

\subsubsection{The exponent}

\begin{enumerate}
\item If the encoding begins with a 0, all digits processed here are read as inverted.
\item  Call N the number of consecutive 1s until a 0 is found.
\item  N digits are read after the 0 (possibly inverted as in 2).
\item  These digits are prefixed with a 1.
\item  The obtained digits sequence is read as a binary number.
\item  This exponent is this number offset by -2.
\end{enumerate}

\subsection{Decoding the significand}
\begin{enumerate}
\item The first four digits are read as binary number and give the leading decimal digit of the significand.
\item The remaining digits are read in packets of 10 and give the 3-decimal-digit, post-comma declets of the significand.
\item If the overall sign is -, the significand is obtained by taking the difference to 10.
\end{enumerate}

\section{Why it is order-preserving}

The encoding are designed in such a way that, if a < b, then the encoded a (A) comes lexicographically before (<<) the encoded b (B). a's (absolute) exponent is called c, b's exponent is called d. a's significand is called e, b's significand is called f.

1. If a is negative and b is positive, then A begins with 00 and B with 10, so that it A << B.
2. If a and b are both positive, then they both begin with 10.
  2.1. If A's exponent is negative and B's exponent is positive, the next digit in A will be a 0 and that of B a 1, so that A << B.
  2.2. If A's exponent and B's exponent are both positive, and c+2 has less digits than d+2, then A will have less 1s then B in front of the next 0, so that A << B.
  2.2. If A's exponent and B's exponent are both positive but different, then c < d and c+2 has as many digits (N) as d+2 then both A and B will both have N-1 1s followed by a 0. The next N-1 digits after the 0 in A and B correspond to a natural binary representation (with no leading 1) of c and d respectively, so that A << B because the natural binary representations preserve order given a fix number of digits.
  2.3. If A's exponent and B's exponent are both negative but different, then c > d and c+2 has as many digits (N) than d+2 then both A and B will both have N-1 0s followed by a 1. The next N-1 digits after the 0 in A and B (E and F respectively) correspond to an inverted natural binary representation, with no leading 0, of c and d respectively. Since c > d, E << F because it's inverted, and A << B.
  2.4. If A's exponent and B's exponent are equal, then e < f and then both A and B have the same next 2N-1 digits. The next digits of A and B, organized in one group of 4, then groups of 10, are all natural binary representations of e and f and preserve the order, so that A << B.
3. If A and B are both negative, then both begin with 01.
  3.1. If A's exponent is positive and B's exponent is negative, the next digit in A will be a 0 and that of B a 1, so that A << B.
  3.2. If A's exponent and B's exponent are both negative but different, then c < d and c+2 has as many digits (N) than d+2 then both A and B will both have N-1 1s followed by a 0. The next N-1 digits after the 0 in A and B correspond to a natural binary representation (with no leading 1) of c and d respectively, so that A << B because the natural binary representations preserve order given a fix number of digits.
  3.3. If A's exponent and B's exponent are both positive but different, then c > d and c+2 has as many digits (N) than d+2 then both A and B will both have N-1 0s followed by a 1. The next N-1 digits after the 0 in A and B (E and F respectively) correspond to an inverted natural binary representation, with no leading 0, of c and d respectively. Since c > d, E << F because it's inverted, and A << B.
  3.4. If A's exponent and B's exponent are equal, then e > f and both A and B have the same next 2N-1 digits. The next digits of A and B, organized in one group of 4, then groups of 10, are all natural binary representations of 10-e and 10-f and preserve the order. Since 10-e < 10-f, A << B.
4. -0 is encoded as 10 and 10 is lexicographically smaller than the encodings of negative decimals, which begin with 01. it is lexicographically greater than the encodings of positive decimals, which begin with 10 followed by at least one further digit.
5. -INF is encoded as 00 and comes lexicographically before any encoding of a finite decimal.
6. +INF is encoded as 11 and comes lexicographically after any encoding of an finite decimal

\section{Fine-tuning the encoding scheme}

Everything is necessary, except the encoding of -INF, +INF, Nan which are optional. Also, trailing 0s can be removed from the binary encoding and added back while decoding. Finally, in environments where lexicographical encoding is not supported between different lengths, this encoding can be adapted to work at the cost of limiting the range.
A prefix of the binary encoding can be taken as an approximation of the encoded decimal, possibly padded with leading 0s if too short. This works as long as the total stored lengths exceeds the length of the encoding of the sign and exponent, which limits the range.

The binary representation can be used as keys in a B-tree index. The lookup key is encoded only once, after which no decoding is needed to navigate in the B-tree.
Also, the binary representation can be used on a binary storage layer where efficient comparison of decimals is required.

\end{document}
