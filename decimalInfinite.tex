\documentclass{acm_proc_article-sp}
\usepackage{graphicx}
\usepackage{balance} 
\usepackage{multirow}
\usepackage{listings}
\usepackage{url}
\usepackage[usenames,dvipsnames]{color}
\begin{document}

\title{decimalInfinite: A Lossless, Order-Preserving Binary Encoding Of All Decimals}

\numberofauthors{1}

\author{
\alignauthor
Ghislain Fourny\\
       \affaddr{28msec, Inc.}\\
       \affaddr{Z\"urich, Switzerland}\\
       \email{g@28.io}
}
\date{6 March 2015}
\maketitle

\begin{abstract}
Yes, all of them.
\end{abstract}

\section{introduction}
In the early stages of computers, storage was scarce. And it was even scarcer in the processor itself. The first computers supported basic arithmetic operations on 8-bit integers. As more memory was needed, the size of the registers in the processor architecture was increased to successively 16 bits, 32 bits and very recently to 64 bits.

While this was mostly driven by the size of the memory, which never failed to exceed the maximum value space at some point, this is also had an impact on the size of integers and decimals processed. This is simply because, in the Von-Neumann architecture, registers are both used to store memory addresses and numbers.

The numbers used in programs are of two main kinds: integers and decimals. Integers are typically supported within a complete interval such as $- 2^{31}$ to $2^{31} -1$. In the case of decimals, it is a bit more complicated. They are limited both in range (driven by the size of their exponent) and in their precision.

For scientists that need to use bigger numbers and/or more precision, special libraries are available, and domain-specific software such as Maple, Mathematica or Matlab make it possible to overcome the limitations of processors and shield the user from the complex machinery that is required to have the processor perform the computations.

In the modern database era, notably document stores, syntaxes such as XML and JSON, but also their data models and the associated query languages, do not impose any limitation on integers or decimals: on the logical level, the entire value space is covered and the limit is only the size of the available storage.

The difference with scientific software, though, is that there is more to it than performing computations. These numbers need to be efficiently stored and retrieved, but most importantly, this must be done in such a way that they can be indexed. For efficiency reasons, it is desirable that this comparison can be done without decoding them. While this is trivial for hash indices, it becomes more difficult for range indices. Indeed, the lexicographical order of encoded values must correspond to the ordering of the corresponding numbers.

State-of-the-art databases, still, do not support yet such an encoding that would cover the entire decimal space (that is, the entire value space of the XML xs:decimal type, or the entire value space of JSON numbers).

This paper contributes an encoding that solves this problem. The encoding and decoding algorithms have been implemented in C++ and are used on production machines to store decimals as BSON binaries, on a MongoDB data store.

\subsection{Outline of the encoding}

The encoding relies on decomposing the underlying decimal into a normal form, as is typically done in other encodings. This decomposition is made of an overall sign, an exponent sign, an exponent and a significand. These four components are encoded in turn and in this order.

Section \ref{section-related-work} gives an overview of the integer and decimal encoding landscape.
TODO
Finally, we give a few hints on how the encoding can be fine-tuned to specific needs, such as also supporting special values such as negative 0, NaN, and infinity.

\section{Related work}
\label{section-related-work}

\subsection{Natural encoding}

Positive integers have a natural encoding which is simply their representation in base 2, as shown on figure \ref{figure-natural-encoding}.

\begin{figure}
\caption{Natural encoding of an integer (base 2)}
\label{figure-natural-encoding}
\center
\begin{tabular}{|l|l|}
\hline
1 & 1 \\
\hline
10 & 2 \\
\hline
11 & 3 \\
\hline
100 & 4 \\
\hline
101 & 5 \\
\hline
... & ... \\
\hline
\end{tabular}
\end{figure}

\begin{figure}
\caption{Natural encoding of an integer (base 2, padded to 4 bits), which is order preserving}
\label{figure-natural-encoding-padded}
\center
\begin{tabular}{|l|l|}
\hline
0001 & 1 \\
\hline
0010 & 2 \\
\hline
0011 & 3 \\
\hline
0100 & 4 \\
\hline
0101 & 5 \\
\hline
... & ... \\
\hline
\end{tabular}
\end{figure}

It supports an unlimited range, however is not order-preserving.

If however the range is limited, for example to 8, 16, 32 or 64 bits, as is commonly done in most programming languages, and the encodings are padded with leading 0s, then this encoding becomes order-preserving.

\subsection{Signed Integers}

Signed integers are commonly stored by encoding the sign in the first bit, meaning that positive integers (beginning with a 0, which is half the range) are stored in the same way as the unsigned encoding, while negative integers are stored beginning with a 1. Lexicographical order is only preserved for positive integers, for negative integers, but not overall.

\begin{figure}
\caption{Natural encoding of a signed integers (base 2, padded to 4 bits)}
\label{figure-natural-encoding-padded}
\center
\begin{tabular}{|l|l|}
\hline
1101 & -3 \\
\hline
1110 & -2 \\
\hline
1111 & -1 \\
\hline
0000 & 0 \\
\hline
0001 & 1 \\
\hline
0010 & 2 \\
\hline
0011 & 3 \\
\hline
0100 & 4 \\
\hline
0101 & 5 \\
\hline
... & ... \\
\hline
\end{tabular}
\end{figure}

\subsection{Elias Gamma Code}

Gamma codes are a variable length encoding that supports the entire non-negative integer range ($\mathbb{N}$). One of their main usage and motivation is that they are prefix-free, meaning that they can get concatenated to each other in a way that they can still be separated again unambiguously. Figure \ref{figure-gamma-encoding} shows how it looks like for the first integers.

\begin{figure}
\caption{The Gamma Code for the first non-negative integers}
\label{figure-gamma-encoding}
\center
\begin{tabular}{|l|l|}
\hline
1 & 0 \\
\hline
01 0 & 1 \\
\hline
01 1 & 2 \\
\hline
001 00 & 3 \\
\hline
001 01 & 4 \\
\hline
001 10 & 5 \\
\hline
... & ... \\
\hline
\end{tabular}
\end{figure}

 The main idea is that a first sequence of 0s, terminated by a 1, encodes the length of the binary-representation of the integer. Then, the natural binary representation of the integer, without its leading 1, follows.

Since the number of 0s is identical to the number of digits that follow after the 1, it is possible to unambiguously deduct where the encoding stops from the number of leading 0s.

For example, 00110010 can be unambiguously separated into 00110 (5) and 010 (1).

The Gamma code in its original form is not order preserving. However, simply inverting the first sequence of 0s and the terminating 1 solves the issue, as is shown on Figure \ref{figure-gamma-encoding-tweaked}

\begin{figure}
\caption{A slight modification of the Gamma Code that makes it order-preserving}
\label{figure-gamma-encoding-tweaked}
\center
\begin{tabular}{|l|l|}
\hline
0 & 0 \\
\hline
10 0 & 1 \\
\hline
10 1 & 2 \\
\hline
110 00 & 3 \\
\hline
110 01 & 4 \\
\hline
110 10 & 5 \\
\hline
... & ... \\
\hline
\end{tabular}
\end{figure}


\subsection{IEEE float and double encoding}

The IEEE 754 standard specifies a couple of standard, floating-point encoding for decimals more commonly known as float or double. It both supports a finite range of decimals (its length is fixed), and is not order-preserving. It has several variants (binary16, binary32, binary64, binary128, decimal32, decimal64, decimal128) depending on the length and on the way the mantissa is encoded.

\subsection{IBM Patent}
The US Patent 7685214 (``Order-preserving encoding formats of floating-point decimal numbers for efficient value comparison'') , filed by IBM, solves the order-preserving issue, but with a finite-length encoding, which implies that it supports a finite range of decimals only.

\section{Encoding}

Let us now get into the details of the encoding itself. The general idea is any non-zero decimal can be expressed in a canonical scientific form with four components (sign, exponent sign, exponent, mantissa). These four components can be encoded separately and concatenated. Since each of the components is encoded prefix-free, it can be unambiguously decoded again.

\subsection{Encoding of zero}

Zero is handled separately and encoded as $10$.

\subsection{Canonical decomposition}

Any decimal number, except zero, can be expressed uniquely in scientific notation as in commonly done in literature, that is, in the form

$$s\times m \times10^{t\times e}$$

where:

\begin{itemize}
\item The overall sign is $s\in \{-1, 1\}$.
\item The exponent $e\in \mathbb{N}$ is a non-negative integer (which is the absolute value of the logarithm in base ten of the original number rounded down to the next integer).
\item The exponent sign is $t\in \{-1, 1\}$.
\item The mantissa (significand) is $m\in [1,10)$, a real number between 1 (included) and 10 (excluded).
\end{itemize}

If S denotes the encoding s, T that of t and so on, then the overall encoding comes naturally as STEM as shown on figure \ref{figure-overall-encoding}. This is because decimal numbers in scientific notation can be sorted with the following criteria in this order:
\begin{enumerate}
\item sign
\item exponent sign
\item exponent
\item mantissa
\end{enumerate}

\begin{figure}
\caption{Encoding of an overall decimal in scientific notation $s\times m \times10^{t\times e}$}
\label{figure-overall-encoding}
\center
\begin{tabular}{|l|l|l|l|}
\hline
$S$ & $T$ & $E$ & $M$ \\
\hline
\end{tabular}
\end{figure}

\subsection{Encoding the sign}

The sign of a decimal is encoded on two bits as shown on Figure \ref{figure-sign}

\begin{figure}
\caption{Encoding of the overall decimal sign}
\label{figure-sign}
\center
\begin{tabular}{|l|l|}
\hline
S & Sign s \\
\hline
00 &  negative sign ($s=-1$, e.g., $-4.3\times10^3$)\\
\hline
10 & positive sign ($s=1$, e.g., $4.3\times10^3$)\\
\hline
\end{tabular}
\end{figure}

Since, zero is simply encoded with $10$ with no further bits, it is already apparent that its encoding appears lexicographically after the encoding of any negative decimal, and before the encoding of any positive decimal.

The reason for using two bits rather than just one is that negative infinity (-INF), positive infinity (+INF) as well as negative zero and NaN can be conveniently encoded as well (see Figure \ref{figure-sign-extended}).

\subsection{Encoding the exponent}
\begin{enumerate}
\item The exponent is offset by +2.
\item  The exponent is written in a binary form.
\item  Call N the number of its digits.
\item  The first digit is replaced with N-1 ones, followed by a zero.
\item  If the overall sign and the sign of its exponent are different, all digits are inverted (NOT).
\end{enumerate}

\subsection{Encoding the significand}
\begin{enumerate}
\item If the sign of the decimal is negative, 10-S is encoded instead.
\item Decomposition into one leading digit, followed by groups of 3 digits (declets) after the comma.
\item Padding of the last declet with 0s to make sure it also has 3 digits.
\item Encoding of the leading digit in 4 bits (natural binary representation).
\item Encoding of each declet in 10 bits (natural binary representation).
\end{enumerate}

\section{Decoding}

\subsection{Decoding the exponent}

\subsubsection{The exponent sign}

\begin{enumerate}
\item If the overall sign is - and the encoding begins with a 0, the exponent sign is +.
\item If the overall sign is - and the encoding begins with a 1, the exponent sign is -.
\item If the overall sign is + and the encoding begins with a 0, the exponent sign is -.
\item If the overall sign is + and the encoding begins with a 1, the exponent sign is +.
\end{enumerate}

\subsubsection{The exponent}

\begin{enumerate}
\item If the encoding begins with a 0, all digits processed here are read as inverted.
\item  Call N the number of consecutive 1s until a 0 is found.
\item  N digits are read after the 0 (possibly inverted as in 2).
\item  These digits are prefixed with a 1.
\item  The obtained digits sequence is read as a binary number.
\item  This exponent is this number offset by -2.
\end{enumerate}

\subsection{Decoding the significand}
\begin{enumerate}
\item The first four digits are read as binary number and give the leading decimal digit of the significand.
\item The remaining digits are read in packets of 10 and give the 3-decimal-digit, post-comma declets of the significand.
\item If the overall sign is -, the significand is obtained by taking the difference to 10.
\end{enumerate}

\section{Why it is order-preserving}

The encoding are designed in such a way that, if a < b, then the encoded a (A) comes lexicographically before (<<) the encoded b (B). a's (absolute) exponent is called c, b's exponent is called d. a's significand is called e, b's significand is called f.

1. If a is negative and b is positive, then A begins with 00 and B with 10, so that it A << B.
2. If a and b are both positive, then they both begin with 10.
  2.1. If A's exponent is negative and B's exponent is positive, the next digit in A will be a 0 and that of B a 1, so that A << B.
  2.2. If A's exponent and B's exponent are both positive, and c+2 has less digits than d+2, then A will have less 1s then B in front of the next 0, so that A << B.
  2.2. If A's exponent and B's exponent are both positive but different, then c < d and c+2 has as many digits (N) as d+2 then both A and B will both have N-1 1s followed by a 0. The next N-1 digits after the 0 in A and B correspond to a natural binary representation (with no leading 1) of c and d respectively, so that A << B because the natural binary representations preserve order given a fix number of digits.
  2.3. If A's exponent and B's exponent are both negative but different, then c > d and c+2 has as many digits (N) than d+2 then both A and B will both have N-1 0s followed by a 1. The next N-1 digits after the 0 in A and B (E and F respectively) correspond to an inverted natural binary representation, with no leading 0, of c and d respectively. Since c > d, E << F because it's inverted, and A << B.
  2.4. If A's exponent and B's exponent are equal, then e < f and then both A and B have the same next 2N-1 digits. The next digits of A and B, organized in one group of 4, then groups of 10, are all natural binary representations of e and f and preserve the order, so that A << B.
3. If A and B are both negative, then both begin with 01.
  3.1. If A's exponent is positive and B's exponent is negative, the next digit in A will be a 0 and that of B a 1, so that A << B.
  3.2. If A's exponent and B's exponent are both negative but different, then c < d and c+2 has as many digits (N) than d+2 then both A and B will both have N-1 1s followed by a 0. The next N-1 digits after the 0 in A and B correspond to a natural binary representation (with no leading 1) of c and d respectively, so that A << B because the natural binary representations preserve order given a fix number of digits.
  3.3. If A's exponent and B's exponent are both positive but different, then c > d and c+2 has as many digits (N) than d+2 then both A and B will both have N-1 0s followed by a 1. The next N-1 digits after the 0 in A and B (E and F respectively) correspond to an inverted natural binary representation, with no leading 0, of c and d respectively. Since c > d, E << F because it's inverted, and A << B.
  3.4. If A's exponent and B's exponent are equal, then e > f and both A and B have the same next 2N-1 digits. The next digits of A and B, organized in one group of 4, then groups of 10, are all natural binary representations of 10-e and 10-f and preserve the order. Since 10-e < 10-f, A << B.
4. -0 is encoded as 10 and 10 is lexicographically smaller than the encodings of negative decimals, which begin with 01. it is lexicographically greater than the encodings of positive decimals, which begin with 10 followed by at least one further digit.
5. -INF is encoded as 00 and comes lexicographically before any encoding of a finite decimal.
6. +INF is encoded as 11 and comes lexicographically after any encoding of an finite decimal

\section{Fine-tuning the encoding scheme}

\begin{figure}
\caption{Encoding of the overall decimal sign}
\label{figure-sign-extended}
\center
\begin{tabular}{|l|l|}
\hline
0 & NaN \\
\hline
00 & -INF \\
\hline
00... &  negative sign (e.g., $-4.3\times10^3$)\\
\hline
01 & negative zero \\
\hline
10 & positive zero \\
\hline
10... & positive sign (e.g., $4.3\times10^3$)\\
\hline
11 & +INF \\
\hline
\end{tabular}
\end{figure}


Everything is necessary, except the encoding of -INF, +INF, Nan which are optional. Also, trailing 0s can be removed from the binary encoding and added back while decoding. Finally, in environments where lexicographical encoding is not supported between different lengths, this encoding can be adapted to work at the cost of limiting the range.
A prefix of the binary encoding can be taken as an approximation of the encoded decimal, possibly padded with leading 0s if too short. This works as long as the total stored lengths exceeds the length of the encoding of the sign and exponent, which limits the range.

The binary representation can be used as keys in a B-tree index. The lookup key is encoded only once, after which no decoding is needed to navigate in the B-tree.
Also, the binary representation can be used on a binary storage layer where efficient comparison of decimals is required.

\end{document}
