\documentclass{acm_proc_article-sp}
\usepackage{graphicx}
\usepackage{balance} 
\usepackage{multirow}
\usepackage{listings}
\usepackage{url}
\usepackage[usenames,dvipsnames]{color}
\begin{document}

\title{decimalInfinite: A Lossless, Order-Preserving Binary Encoding Of All Decimals}

\numberofauthors{1}

\author{
\alignauthor
Ghislain Fourny\\
       \affaddr{28msec, Inc.}\\
       \affaddr{Z\"urich, Switzerland}\\
       \email{g@28.io}
}
\date{6 March 2015}
\maketitle

\begin{abstract}
Yes, all of them.
\end{abstract}

\section{introduction}
In the early stages of computers, storage was scarce. And it was even scarcer in the processor itself. The first computers supported basic arithmetic operations on 8-bit integers. As more memory was needed, the size of the registers in the processor architecture was increased to successively 16 bits, 32 bits and very recently to 64 bits.

While this was mostly driven by the size of the memory, which never failed to exceed the maximum value space at some point, this is also had an impact on the size of integers and decimals processed. This is simply because, in the Von-Neumann architecture, registers are both used to store memory addresses and numbers.

The numbers used in programs are of two main kinds: integers and decimals. Integers are typically supported within a complete interval such as $- 2^{31}$ to $2^{31} -1$. In the case of decimals, it is a bit more complicated. They are limited both in range (driven by the size of their exponent) and in their precision.

For scientists that need to use bigger numbers and/or more precision, special libraries are available, and domain-specific software such as Maple, Mathematica or Matlab make it possible to overcome the limitations of processors and shield the user from the complex machinery that is required to have the processor perform the computations.

In the modern database era, notably document stores, syntaxes such as XML and JSON, but also their data models and the associated query languages, do not impose any limitation on integers or decimals: on the logical level, the entire value space is covered and the limit is only the size of the available storage.

The difference with scientific software, though, is that there is more to it than performing computations. These numbers need to be efficiently stored and retrieved, but most importantly, this must be done in such a way that they can be indexed. For efficiency reasons, it is desirable that this comparison can be done without decoding them. While this is trivial for hash indices, it becomes more difficult for range indices. Indeed, the lexicographical order of encoded values must correspond to the ordering of the corresponding numbers.

To the extent of our knowledge and our investigations, state-of-the-art databases, still, do not support yet such an encoding that would cover the entire decimal space (that is, the entire value space of the XML xs:decimal type, or the entire value space of JSON numbers). However, many encodings exist that have some of the desired properties. decimalInfinite unifies the ideas in these encodings in such a way that all these properties apply simultaneously.

This paper contributes an encoding that solves this problem. The encoding and decoding algorithms have been implemented in C++ and are used on production machines to store decimals as BSON binaries, on a MongoDB data store.

\subsection{Outline of the encoding}

The encoding relies on decomposing the underlying decimal into a normal form, as is typically done in other encodings. This decomposition is made of an overall sign, an exponent sign, an exponent and a significand (mantissa). These four components are encoded in turn and in this order.

Section \ref{section-related-work} gives an overview of the integer and decimal encoding landscape.
TODO
Finally, we give a few hints on how the encoding can be fine-tuned to specific needs, such as also supporting special values such as negative 0, NaN, and infinity.

\section{Related work}
\label{section-related-work}

\subsection{Natural encoding}

Positive integers have a natural encoding which is simply their representation in base 2, as shown on figure \ref{figure-natural-encoding}.

\begin{figure}
\caption{Natural encoding of an integer (base 2)}
\label{figure-natural-encoding}
\center
\begin{tabular}{|l|l|}
\hline
Integer & Binary representation \\
\hline
1 & 1 \\
\hline
2 & 10 \\
\hline
3 & 11 \\
\hline
4 & 100  \\
\hline
5 & 101  \\
\hline
... & ... \\
\hline
\end{tabular}
\end{figure}

\begin{figure}
\caption{Natural encoding of an integer (base 2, padded to 4 bits), which is order preserving}
\label{figure-natural-encoding-padded}
\center
\begin{tabular}{|l|l|}
\hline
Integer & Binary representation (padded with 0s) \\
\hline
1 & 0001 \\
\hline
2 & 0010 \\
\hline
3 & 0011 \\
\hline
4 & 0100 \\
\hline
5 & 0101 \\
\hline
... & ... \\
\hline
\end{tabular}
\end{figure}

It supports an unlimited range, however is not order-preserving.

If however the range is limited, for example to 8, 16, 32 or 64 bits, as is commonly done in most programming languages, and the encodings are padded with leading 0s, then this encoding becomes order-preserving.

\subsection{Signed Integers}

Signed integers are commonly stored by encoding the sign in the first bit, meaning that positive integers (beginning with a 0, which is half the range) are stored in the same way as the unsigned encoding, while negative integers are stored beginning with a 1. Lexicographical order is only preserved for positive integers, for negative integers, but not overall.

\begin{figure}
\caption{Natural encoding of a signed integers (base 2, padded to 4 bits)}
\label{figure-natural-encoding-padded}
\center
\begin{tabular}{|l|l|}
\hline
Integer & Signed binary representation \\
\hline
-3 & 1101 \\
\hline
-2 & 1110 \\
\hline
-1 & 1111 \\
\hline
0 & 0000 \\
\hline
1 & 0001 \\
\hline
2 & 0010 \\
\hline
3 & 0011 \\
\hline
... & ... \\
\hline
\end{tabular}
\end{figure}

\subsection{Elias Gamma Code}
\label{section-gamma-code}

Gamma codes are a variable length encoding that supports the entire non-negative integer range ($\mathbb{N}$). One of their main usage and motivation is that they are prefix-free, meaning that they can get concatenated to each other in a way that they can still be separated again unambiguously. Figure \ref{figure-gamma-encoding} shows how it looks like for the first integers.

\begin{figure}
\caption{The Gamma Code for the first non-negative integers}
\label{figure-gamma-encoding}
\center
\begin{tabular}{|l|l|l|}
\hline
Integer & Offset integer & Gamma \\
\hline
0 & 1 (1) & 1 \\
\hline
1 & 2 (10) & 01 0  \\
\hline
2 & 3 (11) & 01 1  \\
\hline
3 & 4 (100) & 001 00 \\
\hline
4 & 5 (101) & 001 01 \\
\hline
5 & 6 (110) & 001 10 \\
\hline
... & ... \\
\hline
\end{tabular}
\end{figure}

 The main idea is that a first sequence of 0s, terminated by a 1, encodes the length of the binary-representation of the integer. Then, the natural binary representation of the integer (most of the time offset by 1), without its leading 1, follows.

Since the number of 0s is identical to the number of digits that follow after the 1, it is possible to unambiguously deduct where the encoding stops from the number of leading 0s.

For example, 00110010 can be unambiguously separated into 00110 (5) and 010 (1).

The Gamma code in its original form is order preserving. However, simply inverting the first sequence of 0s and the terminating 1 solves the issue, as is shown on Figure \ref{figure-gamma-encoding-tweaked}.

\begin{figure}
\caption{A slight modification of the Gamma Code that makes it order-preserving}
\label{figure-gamma-encoding-tweaked}
\center
\begin{tabular}{|l|l|}
\hline
Integer & Gamma (order-preserving) \\
\hline
0 & 0 \\
\hline
1 & 10 0  \\
\hline
2 & 10 1  \\
\hline
3 & 110 00 \\
\hline
4 & 110 01 \\
\hline
5 & 110 10 \\
\hline
... & ... \\
\hline
\end{tabular}
\end{figure}


\subsection{IEEE float and double encoding}

The IEEE 754 standard specifies a couple of standard, floating-point encoding for decimals more commonly known as float or double. It both supports a finite range of decimals (its length is fixed), and is not order-preserving. It has several variants (binary16, binary32, binary64, binary128, decimal32, decimal64, decimal128) depending on the length and on the way the mantissa is encoded.

\subsection{IBM Patent}
The US Patent 7685214 (``Order-preserving encoding formats of floating-point decimal numbers for efficient value comparison'') , filed by IBM, solves the order-preserving issue, but with a finite-length encoding, which implies that it supports a finite range of decimals only.

One very interesting idea in this approach is that, if the sign is negative, the mantissa m is encoded as 10-m to preserve the order.

\section{Encoding}

Let us now get into the details of the encoding itself. The general idea is any non-zero decimal can be expressed in a canonical scientific form with four components (sign, exponent sign, exponent, mantissa). These four components can be encoded separately and concatenated. Since each of the components is encoded prefix-free, it can be unambiguously decoded again.

\subsection{Encoding of zero}

Zero is handled separately and encoded as $10$.

\subsection{Canonical decomposition}

Any decimal number, except zero, can be expressed uniquely in scientific notation as in commonly done in literature, that is, in the form

$$s\times m \times10^{t\times e}$$

where:

\begin{itemize}
\item The overall sign is $s\in \{-1, 1\}$.
\item The exponent $e\in \mathbb{N}$ is a non-negative integer (which is the absolute value of the logarithm in base ten of the original number rounded down to the next integer).
\item The exponent sign is $t\in \{-1, 1\}$.
\item The mantissa (significand) is $m\in [1,10)$, a real number between 1 (included) and 10 (excluded).
\end{itemize}

If S denotes the encoding s, T that of t and so on, then the overall encoding comes naturally as STEM as shown on figure \ref{figure-overall-encoding}. This is because decimal numbers in scientific notation can be sorted with the following criteria in this order:
\begin{enumerate}
\item sign
\item exponent sign
\item exponent
\item mantissa
\end{enumerate}

\begin{figure}
\caption{Encoding of an overall decimal in scientific notation $s\times m \times10^{t\times e}$}
\label{figure-overall-encoding}
\center
\begin{tabular}{|l|l|l|l|}
\hline
$S$ & $T$ & $E$ & $M$ \\
\hline
\end{tabular}
\end{figure}

Throughout this paper, four examples, which cover various combinations of the four components, will be used:

$$-103.2 = - 1.032 \times 10^2$$

$$-0.0405 = -4.05 \times 10^{-2}$$

$$0.707106 = 7.07106 \times 10^{-1}$$

$$4005012345 = 4.005012345 \times 10^9$$


\subsection{Encoding the sign}

The sign of a decimal is encoded on two bits as shown on Figure \ref{figure-sign}

\begin{figure}
\caption{Encoding of the overall decimal sign}
\label{figure-sign}
\center
\begin{tabular}{|l|l|}
\hline
S & Sign s \\
\hline
00 &  negative sign ($s=-1$, e.g., $-4.3\times10^3$)\\
\hline
10 & positive sign ($s=1$, e.g., $4.3\times10^3$)\\
\hline
\end{tabular}
\end{figure}

Since, zero is simply encoded with $10$ with no further bits, it is already apparent that its encoding appears lexicographically after the encoding of any negative decimal, and before the encoding of any positive decimal.

The reason for using two bits rather than just one is that negative infinity (-INF), positive infinity (+INF) as well as negative zero and NaN can be conveniently encoded as well (see Figure \ref{figure-sign-extended}).

So far, our four example have an encoding that begins as follow:

\begin{tabular}{l|l}
$- 1.032 \times 10^2$ & 00... \\

$-4.05 \times 10^{-2}$ & 00... \\

$0$ & 10 \\

$7.07106 \times 10^{-1}$ & 10... \\

$4.005012345 \times 10^9$ & 10...\\
\end{tabular}
\subsection{Encoding the exponent sign}

The exponent sign is encoded by either negating or not negating all bits in the encoding of the absolute value of the exponent (Section \ref{section-exponent-encoding}), in such a way that the third bit be a 0 or a 1 as shown on figure \ref{figure-exponent-sign}.

\begin{figure}
\caption{Encoding of the exponent sign}
\label{figure-exponent-sign}
\center
\begin{tabular}{|l|l|}
\hline
S and T & s and t \\
\hline
00 0 &  negative sign, positive exponent sign\\
\hline
00 1 &  negative sign, negative exponent sign\\
\hline
10 0 & positive sign, negative exponent sign\\
\hline
10 1 & positive sign, positive exponent sign\\
\hline
\end{tabular}
\end{figure}

The encoding of our four examples continues as follows:

\begin{tabular}{l|l}
$- 1.032 \times 10^2$ & 00 0... \\

$-4.05 \times 10^{-2}$ & 00 1... \\

$7.07106 \times 10^{-1}$ & 10 0... \\

$4.005012345 \times 10^9$ & 10 1...\\
\end{tabular}

\subsection{Encoding the exponent}

The absolute value of the exponent is encoded with a modified gamma code (as explained in section \ref{section-gamma-code}), using an offset of 2.

\label{section-exponent-encoding}
\begin{enumerate}
\item The exponent is offset by +2, for example, 4 is encoded with the modified gamma code of 6. 
\item  The offset exponent is written in a binary form, for example, 6 is written 110.
\item  Call N the number of its digits (in the case of 110: 3).
\item  The first digit is replaced with N-1 ones, followed by a zero (in the case of 110: 110 10)
\end{enumerate}

Figure \ref{figure-exponent-encoding} shows how the smallest absolute values of the exponent are encoded. If the overall sign and the exponent sign are identical, this is how it appears in the final encoding. Otherwise, all the bits are negated.

\begin{figure}
\caption{A slight modification of the Gamma Code that makes it order-preserving}
\label{figure-exponent-encoding}
\center
\begin{tabular}{|l|l|l|}
\hline
Integer & Integer offset by 2 & Exponent encoding\\
\hline
0 & 2 (10) & 10 0 \\
\hline
1 & 3 (11) & 10 1  \\
\hline
2 & 4 (100) & 110 00  \\
\hline
3 & 5 (101) & 110 01 \\
\hline
4 & 6 (110) & 110 10 \\
\hline
5 & 7 (111) & 110 11 \\
\hline
6 & 8 (1000) & 1110 000 \\
\hline
7 & 9 (1001) & 1110 001 \\
\hline
8 & 10 (1010) & 1110 010 \\
\hline
9 & 11 (1011) & 1110 011 \\
\hline
... & ... & ...\\
\hline
\end{tabular}
\end{figure}

The encoding of our four examples continues as follows:

\begin{tabular}{l|l}
$- 1.032 \times 10^2$ ($e=2$, opposite signs) & 00 001 11... \\

$-4.05 \times 10^{-2}$ ($e=2$, same signs) & 00 110 00... \\

$7.07106 \times 10^{-1}$ ($e=1$, opposite signs) & 10 01 0... \\

$4.005012345 \times 10^9$ ($e=9$, same signs) & 10 1110 011...\\
\end{tabular}


\subsection{Encoding the significand}

The mantissa is encoded in a way similar to decimal32, decimal64 and decimal128, that is:

\begin{itemize}
\item its initial digit (before the comma) is encoded on 4 bits in its natural binary representation.
\item the remaining digits (after the comma) are grouped 3 by 3 (declets). Each declet is encoded in its natural binary representation on 10 bits. Trailing 0s are added to make sure that the last group also has 3 digits.
\end{itemize}

If the overall sign of the decimal is negative though, a trick similar to the IBM patent is used: 10-m is encoded instead of m (in this case, the leading digit may be a 0 and will never be a 9).

\begin{figure}
\caption{Examples of mantissa encodings}
\label{figure-mantissa-encoding}
\center
\begin{tabular}{|l|l|l|l}
\hline
$8.968 (=10-1.023)$ & 8 968 & 1000 \\
& & 1111001000 \\
\hline
$5.95 (=10-4.05)$ & 5 950 & 0101 \\
& & 1110110110\\
\hline
$7.07106$ & 7 071 060 & 0111 \\
& & 0001000111\\
& & 0001111000\\
\hline
$4.005012345$ & 4 005 012 345 & 0100 \\
& & 0000000101\\
& & 0000001100\\
& & 0101011001\\
\hline
\end{tabular}
\end{figure}

The encoding of our four examples can now be completed:

\begin{tabular}{l}
$- 1.032 \times 10^2$ (10-m is taken)\\
00 001 11 1000 1111001000\\
\\
$-4.05 \times 10^{-2}$ (10-m is taken)\\
00 110 00 0101 1110110110\\
\\
$7.07106 \times 10^{-1}$\\
10 01 0 0111 0001000111 0001111000\\
\\
$4.005012345 \times 10^9$\\
10 1110 011 0100 0000000101 0000001100 0101011001\\
\end{tabular}

\section{Decoding}

\subsection{Decoding the exponent}

\subsubsection{The exponent sign}

\begin{enumerate}
\item If the overall sign is - and the encoding begins with a 0, the exponent sign is +.
\item If the overall sign is - and the encoding begins with a 1, the exponent sign is -.
\item If the overall sign is + and the encoding begins with a 0, the exponent sign is -.
\item If the overall sign is + and the encoding begins with a 1, the exponent sign is +.
\end{enumerate}

\subsubsection{The exponent}

\begin{enumerate}
\item If the encoding begins with a 0, all digits processed here are read as inverted.
\item  Call N the number of consecutive 1s until a 0 is found.
\item  N digits are read after the 0 (possibly inverted as in 2).
\item  These digits are prefixed with a 1.
\item  The obtained digits sequence is read as a binary number.
\item  This exponent is this number offset by -2.
\end{enumerate}

\subsection{Decoding the significand}
\begin{enumerate}
\item The first four digits are read as binary number and give the leading decimal digit of the significand.
\item The remaining digits are read in packets of 10 and give the 3-decimal-digit, post-comma declets of the significand.
\item If the overall sign is -, the significand is obtained by taking the difference to 10.
\end{enumerate}

\section{Why it is order-preserving}

The encoding are designed in such a way that, if a < b, then the encoded a (A) comes lexicographically before (<<) the encoded b (B). a's (absolute) exponent is called c, b's exponent is called d. a's significand is called e, b's significand is called f.

1. If a is negative and b is positive, then A begins with 00 and B with 10, so that it A << B.
2. If a and b are both positive, then they both begin with 10.
  2.1. If A's exponent is negative and B's exponent is positive, the next digit in A will be a 0 and that of B a 1, so that A << B.
  2.2. If A's exponent and B's exponent are both positive, and c+2 has less digits than d+2, then A will have less 1s then B in front of the next 0, so that A << B.
  2.2. If A's exponent and B's exponent are both positive but different, then c < d and c+2 has as many digits (N) as d+2 then both A and B will both have N-1 1s followed by a 0. The next N-1 digits after the 0 in A and B correspond to a natural binary representation (with no leading 1) of c and d respectively, so that A << B because the natural binary representations preserve order given a fix number of digits.
  2.3. If A's exponent and B's exponent are both negative but different, then c > d and c+2 has as many digits (N) than d+2 then both A and B will both have N-1 0s followed by a 1. The next N-1 digits after the 0 in A and B (E and F respectively) correspond to an inverted natural binary representation, with no leading 0, of c and d respectively. Since c > d, E << F because it's inverted, and A << B.
  2.4. If A's exponent and B's exponent are equal, then e < f and then both A and B have the same next 2N-1 digits. The next digits of A and B, organized in one group of 4, then groups of 10, are all natural binary representations of e and f and preserve the order, so that A << B.
3. If A and B are both negative, then both begin with 01.
  3.1. If A's exponent is positive and B's exponent is negative, the next digit in A will be a 0 and that of B a 1, so that A << B.
  3.2. If A's exponent and B's exponent are both negative but different, then c < d and c+2 has as many digits (N) than d+2 then both A and B will both have N-1 1s followed by a 0. The next N-1 digits after the 0 in A and B correspond to a natural binary representation (with no leading 1) of c and d respectively, so that A << B because the natural binary representations preserve order given a fix number of digits.
  3.3. If A's exponent and B's exponent are both positive but different, then c > d and c+2 has as many digits (N) than d+2 then both A and B will both have N-1 0s followed by a 1. The next N-1 digits after the 0 in A and B (E and F respectively) correspond to an inverted natural binary representation, with no leading 0, of c and d respectively. Since c > d, E << F because it's inverted, and A << B.
  3.4. If A's exponent and B's exponent are equal, then e > f and both A and B have the same next 2N-1 digits. The next digits of A and B, organized in one group of 4, then groups of 10, are all natural binary representations of 10-e and 10-f and preserve the order. Since 10-e < 10-f, A << B.
4. -0 is encoded as 10 and 10 is lexicographically smaller than the encodings of negative decimals, which begin with 01. it is lexicographically greater than the encodings of positive decimals, which begin with 10 followed by at least one further digit.
5. -INF is encoded as 00 and comes lexicographically before any encoding of a finite decimal.
6. +INF is encoded as 11 and comes lexicographically after any encoding of an finite decimal

\section{Fine-tuning the encoding scheme}

\begin{figure}
\caption{Encoding of the overall decimal sign}
\label{figure-sign-extended}
\center
\begin{tabular}{|l|l|}
\hline
0 & NaN \\
\hline
00 & -INF \\
\hline
00... &  negative sign (e.g., $-4.3\times10^3$)\\
\hline
01 & negative zero \\
\hline
10 & positive zero \\
\hline
10... & positive sign (e.g., $4.3\times10^3$)\\
\hline
11 & +INF \\
\hline
\end{tabular}
\end{figure}


Everything is necessary, except the encoding of -INF, +INF, Nan which are optional. Also, trailing 0s can be removed from the binary encoding and added back while decoding. Finally, in environments where lexicographical encoding is not supported between different lengths, this encoding can be adapted to work at the cost of limiting the range.
A prefix of the binary encoding can be taken as an approximation of the encoded decimal, possibly padded with leading 0s if too short. This works as long as the total stored lengths exceeds the length of the encoding of the sign and exponent, which limits the range.

The binary representation can be used as keys in a B-tree index. The lookup key is encoded only once, after which no decoding is needed to navigate in the B-tree.
Also, the binary representation can be used on a binary storage layer where efficient comparison of decimals is required.

\end{document}
